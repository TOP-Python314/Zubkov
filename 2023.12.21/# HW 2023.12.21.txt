ПРОДВИНУТАЯ РАБОТА С ФУНКЦИЯМИ

  ==========  1  ==========  

Написать функцию с именем pick_resistors, которая подбирает ближайшие к переданному номиналы сопротивления из всех рядов сопротивлений.

В электротехнике и электронике существует понятие разброса значения сопротивления резистора от номинала. Результатом этого явилось существование рядов номиналов резисторов, изготавливаемых с различной точностью: от ±20% до ±0.5%
    Подробнее здесь: https://digteh.ru/PCB/R/Nominal/

Необходимо для некоторого (заранее рассчитанного) значения сопротивления подобрать ближайший номинал из каждого ряда сопротивлений. Под ближайшими подразумеваются тот или те номиналы, разница которых с переданным значением сопротивления минимальна.
    Ряды номиналов, среди которых необходимо осуществить подбор, заданы в словаре в приложенном к заданию файле # ref 1.py

Функция принимает обязательным позиционно-ключевым аргументом целое число — значение сопротивления в диапазоне от 100 до 999 включительно.

Функция возвращает словарь или None.

    Ключи словаря:
        'Е6', 'Е12', 'Е24', 'Е48', 'Е96'
    
    Значения словаря должны быть объектами tuple. 
    В каждом кортеже должен быть один или больше объектов int — подобранные номиналы сопротивлений.
    
В данной задаче необходимо использовать встроенные функции высшего порядка map() и filter(). Для этих функций в свою очередь понадобится написать подходящие анонимные функции.

Примечание: не забывайте про встроенные функции abs() и min()

Написанную функцию необходимо протестировать вручную.
Пример ручного теста:
    >>> pick_resistors(112)
    {'E6': (100,), 'E12': (120,), 'E24': (110,), 'E48': (110,), 'E96': (113,)}
    >>> 
    >>> pick_resistors(549)
    {'E6': (470,), 'E12': (560,), 'E24': (560,), 'E48': (536, 562), 'E96': (549,)}



  ==========  2  ==========  

Написать генераторную функцию с именем deck, которая создаёт упорядоченную колоду карт.

Функция не принимает аргументы.

Функция возвращает объект генератор.
    
    На каждой итерации или при явном вызове встроенного метода __next__() генератор должен возвращать кортеж из двух элементов:
        - целое число, обозначающее номинал карты: 2, 3 ... 10, 11 — валет, 12 — дама, 13 — король, 14 — туз
        - строка, обозначающая масть карты: 'черви', 'бубны', 'пики', 'трефы'

Колода упорядочивается следующим образом: сначала все номиналы червей, затем все номиналы бубен, затем все номиналы пик и в конце все номиналы треф.

Написанную функцию необходимо протестировать вручную.
Пример ручного теста:
    >>> list(deck())[::13]
    [(2, 'черви'), (2, 'бубны'), (2, 'пики'), (2, 'трефы')]



  ==========  3  ==========  

Написать функцию высшего порядка с именем math_function_resolver, которая вычисляет округлённые значения для различных математических функций.

Функция принимает обязательным аргументом математическую функцию, произвольное количество значений x для математической функции и необязательным аргументом переключатель: тип вычисляемых значений float или str.
    
    Математическая функция должна быть строго позиционным аргументом, передаётся в виде вызываемого объекта.
        Данная функция должна принимать один обязательный позиционно-ключевой аргумент — число x, для которого необходимо вычислить значение математической функции. Это должно быть описано в документации к функции высшего порядка.
    
    Значения x для математической функции должны быть строго позиционными, передаются в виде произвольного кортежа объектов int или float.
    
    Переключатель должен быть строго ключевым, передаётся в виде объекта bool, значение по умолчанию False (тип вычисляемых значений float).

Функция возвращает объект списка с вычисленными значениями математической функции для переданных значений x. Значения должны быть математичеси округлены до целого.
    
    Элементами списка должны быть объекты int или объекты str в зависимости от значения аргумента переключателя.

В данной задаче необходимо минимизировать количество итераций.

Написанную функцию необходимо протестировать вручную.
Пример ручного теста:
    >>> math_function_resolver(lambda x: 0.5*x + 2, *range(1, 10))
    [2, 3, 4, 4, 4, 5, 6, 6, 6]
    >>>
    >>> math_function_resolver(lambda x: -0.5*x + 2, *range(1, 10))
    [2, 1, 0, 0, 0, -1, -2, -2, -2]
    >>>
    >>> math_function_resolver(lambda x: 2.72**x, *range(1, 10), res_to_str=True)
    ['3', '7', '20', '55', '149', '405', '1101', '2996', '8149']



  ==========  4  ==========  дополнительно

Написать параметризуемый декоратор с именем repeat, который выполняет декорируемую функцию заданное количество раз.

Это достаточно распространённая задача в сфере тестирования.

Функция параметризации декораторов repeat принимает необязательным аргументом количество вызовов декорируемой функции.
    
    Количество вызовов декорируемой функции должно быть позиционно-ключевым аргументом, передаётся в виде объекта int, значение по умолчанию 2.

Декоратор может применяться к функциям с различным набором позиционных и ключевых аргументов.

Написанный декоратор необходимо протестировать вручную с помощью дополнительной произвольной функции.
Пример ручного теста:
    >>> def testing_function():
    ...     print('python')
    ...
    >>> testing_function = repeat(testing_function)(4)
    >>> 
    >>> 
    >>> testing_function()
    python
    python
    python
    python



  ==========  5  ==========  

Написать декоратор с именем logger, который в стандартном потоке вывода ведёт журнал вызовов декорируемой функции.

В журнал необходимо внести имя вызванной функции и перечислить переданные аргументы. Ключевые аргументы должны быть перечислены с указанием ключа — имени параметра, в который эти аргументы передаются. 

Помимо переданных аргументов в журнал необходимо внести использованные значения по умолчанию.
    
    Значения по умолчанию доступны в специальных атрибутах объекта функции __defaults__ (позиционные) и __kwdefaults__ (ключевые)
    
    Количество объявленных в функции строго позиционных и позиционно-ключевых параметров доступно в атрибуте функции __code__.co_argcount

В случае возникновения исключения его имя и текст также должны быть внесены в журнал, само исключение при перехвате игнорируется.
    
    Перехват любого исключения (в данном случае требуется перехватывать именно любое исключение, потому что декоратор может быть применён к произвольной функции) возможен при использовании базового класса Exception:
    try:
        int('a')
    except Exception:
        pass
    
    Доступ к объекту исключения возможен при использовании конструкции as <переменная>:
    try:
        sorted(150)
    except TypeError as exception:
        print(exception)
    
    Имя объекта исключения доступно во встроенном атрибуте __name__. Текст исключения (без обратной трассировки) возвращается при получении строкового представления объекта исключения. 
    В примере выше в stdout будет выведено: 'int' object is not iterable.

Декоратор может применяться к функциям с различным набором позиционных и ключевых аргументов.

Написанный декоратор необходимо протестировать вручную с помощью различных дополнительных произвольных функций.
Пример ручного теста:
    >>> def div_round(num1, num2, *, digits=0):
    ...     return round(num1 / num2, digits)
    ...
    >>> div_round = logger(div_round)
    >>> 
    >>> 
    >>> div_round(1, 3, digits=2)
    div_round(1, 3, digits=2) -> 0.33
    0.33
    >>> div_round(7, 2)
    div_round(7, 2, digits=0) -> 4.0
    4.0
    >>> div_round(5, 0)
    div_round(5, 0, digits=0) .. ZeroDivisionError: division by zero
    >>> 



  =========================  

Каждая функция должна быть документирована, её параметры и возвращаемое значение должны быть аннотированы.

Работа функций тестируется в режиме инспекции файла с кодом.
Ввод и вывод тестов в стандартные потоки копируются.
Копия без изменений помещается в конец файла с кодом задачи в виде комментария.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.